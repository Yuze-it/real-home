## T1

根据题目描述，选手编号的前三个字符取决于报名顺序n的范围：

- 第1名到第999名：ABC
- 第1000名到1998名：ABD

因此，只需判断n是否小于1000：若n<1000，输出"ABC"；否则输出"ABD"。

思路：

1. 读取整数n。
2. 如果n <= 999，输出"ABC"。
3. 否则（n>=1000且n<=1998），输出"ABD"。

```c++
#include<iostream>
using namespace std;
int n;
int main(){
    cin>>n;
    if(n<=999) cout<<"ABC";
    else cout<<"ABD";
    return 0;
}
```



## T2

小明选的a块互不相邻，小红选的b块互不相邻。那么小明最多能选8块，小红最多能选8块。因此，如果a>8或者b>8，那么不可能；否则，总是可以（因为环上每个人最多选8个不相邻的块，且总共16块，足够分配）

但这样样例4：a=11>8，所以输出":("，符合

因此，算法为：
如果a<=8且b<=8，则输出"Yay!"，否则输出":("

那么，取等号：为什么样例3（8,8）满足？因为小明可以选8个不相邻的块（例如所有奇数块），小红选8个不相邻的块（所有偶数块），虽然两人选的块之间是相邻的，但题目允许

所以代码非常简单：

```c++
#include<iostream>
using namespace std;
int a,b;
int main(){
    cin>>a>>b;
    if(a<=8&&b<=8) cout<<"Yay!";
    else cout<<":(";
    return 0;
}
```



## T3

设左边塔是第k座，则其实际高度为S(k)=k(k+1)/2
右边塔是第k+1座，实际高度为S(k+1)=(k+1)(k+2)/2
那么实际高度差为S(k+1)-S(k)=k+1

现在，露出雪面的高度：左边为a，右边为b
∴ 有：
实际高度左边：a+d = S(k) = k(k+1)/2
实际高度右边：b+d = S(k+1) = (k+1)(k+2)/2

两式相减：(b+d) - (a+d) = S(k+1)-S(k) = k+1
即：b-a = k+1

∴ k = (b-a) - 1。

then，左边塔的实际高度：a+d = k(k+1)/2
∴ d = k(k+1)/2 - a。

验证样例：a=8, b=13
则k = (13-8)-1=4
d = 4*5/2 - 8 = 10-8 = 2，符合

因此步骤：

1. 计算k = (b-a) - 1
2. 计算d = k*(k+1)/2 - a
3. 输出d

注意：k就是左边塔的编号（第k座），因为高度差为k+1

代码实现：

```c++
#include<iostream>
using namespace std;
int a,b;
int main(){
    cin>>a>>b;
    int k=b-a-1;
    int d=k*(k+1)/2-a;
    cout<<d;
    return 0;
}
```



## T4

**思路分析：**
完全背包：用最少的操作次数（即最少货币数量）凑出n元，但此处的“货币”非普通的硬币，而是两种序列：

1. 1元，以及6的幂（$6^1=6, 6^2=36, 6^3=216, ...$）直到不超过n
2. 9的幂（$9^1=9, 9^2=81, 9^3=729, ...$）直到不超过n

注：1元是始终可用的，而6的幂和9的幂都是可用的“货币”种类

so，我们可以先预处理出所有可用的金额（即所有1元、6的幂、9的幂，且不超过n），然后使用dp求解最小操作次数（即最小货币数）

动态规划步骤：

1. 状态：`dp[i]`表示凑出i元所需的最小操作次数
2. 边界：`dp[0]=0`，`dp[i]=inf（如1e6）`
3. 状态转移（方程）：对于每个可用的金额v（包括1，以及所有不超过n的6的幂和9的幂），更新dp：对于i从v到n，`dp[i]=min(dp[i],dp[i-v]+1)`。

**但是注意**：n最大为100000，而6的幂和9的幂种类不多（$6^1=6, 6^2=36, 6^3=216, 6^4=1296, 6^5=7776, 6^6=46656，6^7=279936>100000$，所以6的幂有6个；9的幂：$9^1=9,9^2=81,9^3=729,9^4=6561,9^5=59049,9^6=531441>100000$，So：9的幂有5个；再加上1元，总共有$1+6+5=12$种“货币”）。

因此，完全背包是可行的（=

代码实现：

1. 预处理出所有可用的金额（放入一个`vector`中）。
2. 初始化dp数组，大小为n+1，初始值设为一个大数（比如1e6），但`dp[0]=0`。
3. 遍历每种金额v，对于每个i从v到n，更新`dp[i]=min(dp[i],dp[i-v]+1)`。
4. 输出`dp[n]`。

```C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int n;
int dp[100005];
vector<int>v;
int main(){
    cin>>n;
    v.push_back(1);
    for(int i=6;i<=n;i*=6){
        v.push_back(i);
    }
    for(int i=9;i<=n;i*=9){
        v.push_back(i);
    }
    for(int i=1;i<=n;i++){
        dp[i]=1000000;
    }//或 fill(dp+1,dp+n+1,1000000);
    dp[0]=0;
    for(auto x:v){
        for(int i=x;i<=n;i++){
            dp[i]=min(dp[i],dp[i-x]+1);
        }
    }
    cout<<dp[n];
    return 0;
}
```

**解释：**

- 首先将1和所有不超过n的6的幂、9的幂加入`vector v`。
- 初始化dp数组，`dp[0]=0`，其他为一个大数（这里1e6足够大，因为n最大1e5，操作次数最多不会超过n）。~~（当然懒得分析也可以直接inf=0x3f3f3f3f（doge~~
- 然后对于v中的每个金额x，进行完全背包的更新。
- 最后输出dp[n]即为最小操作次数。

样例验证：
n=127：最小次数为4（1+9+36+81=127），√
n=3：最小次数为3（1+1+1），√



## T5

**思路分析：**
题目要求将矩阵修改成“好的矩阵”，其中好的矩阵需要满足：

- 对于所有满足` (i+j)%3 == (x+y)%3 `的格子，颜色必须相同。
- 对于所有满足` (i+j)%3 != (x+y)%3 `的格子，颜色必须不同。

实际上，整个矩阵根据 `(i+j)%3 `的值可以分为3类（余数0、1、2）。对于每一类，所有格子必须涂成同一种颜色（但不同类之间必须涂成不同颜色）。

因此，我们需要为这三类（设为组0、组1、组2）分别分配一种颜色（三种颜色互不相同），然后计算将原始矩阵中每组的格子涂成指定颜色的错误值之和，并最小化这个总和。

具体步骤：

1. 预处理：读取n和c，以及错误值矩阵D（c行c列，D[i][j]表示将颜色i改为j的代价）。
2. 读取原始矩阵（n行n列）。
3. 将原始矩阵的格子按照` (i+j)%3 `分成3组（组0、组1、组2）。
4. 对于每组（0、1、2），统计该组中原始颜色出现的频率（即计数每种颜色出现了多少次）。
5. 枚举为组0、组1、组2分配的颜色（颜色编号从1到c），且要求三种颜色互不相同。
   - 设组0分配颜色c0，组1分配颜色c1，组2分配颜色c2（c0、c1、c2互不相同）。
6. 对于每种分配方案，计算总错误值：
   - 对于组0：每个原始颜色为k的格子，错误值为D$[k][c0]$（因为要改为c0）。所以组0的总错误值 = $sum_{k=1}^{c} (count0[k] * D[k][c0])$
   - 同理计算组1和组2。
   - 总错误值 = 组0错误值 + 组1错误值 + 组2错误值
7. 在所有合法的分配方案（c0、c1、c2互不相同）中，找出总错误值最小的。

注意：c最大为30，所以枚举三种颜色（最多30*29*28=24360种情况）是可行的。

代码实现：

- 定义三个数组$cnt[3][c+1]$（用于统计每组中每种颜色的出现次数）。
- 然后三重循环枚举c0、c1、c2（从1到c），且互不相同。
- 计算总代价，取最小值。

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int n,c;
int D[35][35];
int a[505][505];
int cnt[3][35]; //cnt[i][j]: 第i组中颜色j出现的次数

int main(){
    cin>>n>>c;
    for(int i=1;i<=c;i++)
        for(int j=1;j<=c;j++)
            cin>>D[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
            int g=(i+j)%3;
            cnt[g][a[i][j]]++;
        }
    int ans=1e9;
    for(int c0=1;c0<=c;c0++){
        for(int c1=1;c1<=c;c1++){
            if(c1==c0) continue;
            for(int c2=1;c2<=c;c2++){
                if(c2==c0||c2==c1) continue;
                int cost=0;
                for(int k=1;k<=c;k++)
                    cost+=cnt[0][k]*D[k][c0];
                for(int k=1;k<=c;k++)
                    cost+=cnt[1][k]*D[k][c1];
                for(int k=1;k<=c;k++)
                    cost+=cnt[2][k]*D[k][c2];
                ans=min(ans,cost);
            }
        }
    }
    cout<<ans;
    return 0;
}
```

**解释：**

- 首先读取n和c，以及错误值矩阵D（注意颜色编号从1开始）。
- 读取原始矩阵a，并同时根据(i+j)%3将每个格子分到组0、1、2，并统计每组中每种颜色的出现次数。
- 然后三重循环枚举为组0、1、2分配的颜色（c0、c1、c2），且要求互不相同。
- 对于每种分配，计算总错误值：对于每组，将该组中所有原始颜色k改为目标颜色的代价求和。
- 取最小总错误值输出。

样例验证：
样例1：n=2, c=3，错误值矩阵和原始矩阵如输入，计算得到最小错误值为3，正确。
样例2：n=4, c=3，计算得到428，正确。

