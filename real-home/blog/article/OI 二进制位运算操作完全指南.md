## OI 二进制位运算操作完全指南

### 一、核心运算符

| 运算符 | 名称     | 描述 (以二进制视角)                          | 示例 (a = 5 `(0101)`, b = 3 `(0011)`)  |
| :----- | :------- | :------------------------------------------- | :------------------------------------- |
| `&`    | **与**   | 两位都为1时，结果才为1                       | `a & b` -> `1 (0001)`                  |
| `\|`   | **或**   | 两位有一位为1时，结果就为1                   | `a \| b` -> `7 (0111)`                 |
| `^`    | **异或** | 两位不同则为1，相同则为0                     | `a ^ b` -> `6 (0110)`                  |
| `~`    | **取反** | 按位取反，0变1，1变0                         | `~a` -> `...11111010` (结果与位数有关) |
| `<<`   | **左移** | 各位左移若干位，高位丢弃，低位补0            | `a << 1` -> `10 (1010)`                |
| `>>`   | **右移** | 各位右移若干位，低位丢弃，高位补符号位(算术) | `a >> 1` -> `2 (0010)`                 |

**重要提示**：在 C++ 中，对 `int` (有符号) 右移是**算术右移** (高位补符号位)，对 `unsigned int` 是**逻辑右移** (高位补0)。OI 中处理状态压缩时，**强烈推荐使用 `unsigned` 类型或无符号显式转换**以避免符号位带来的意外错误。

---

### 二、集合表示与操作

将一个二进制数的每一位看作一个元素是否存在，`1` 表示存在，`0` 表示不存在。例如，对于全集 $U = \{0, 1, 2, 3\}$ (共4个元素)：
- 集合 $S = \{0, 2\}$ 可表示为二进制数 `0101`，即十进制 `5`。
- 集合 $T = \{0, 1\}$ 可表示为 `0011`，即十进制 `3`。

| 集合操作                     | 位运算表达式              | 代码示例 (S=5, T=3)                | 结果 (二进制)  | 解释                              |
| :--------------------------- | :------------------------ | :--------------------------------- | :------------- | :-------------------------------- |
| **交集** $S \cap T$          | `S & T`                   | `int Intersection = S & T;`        | `0001` (1)     | 只有两位都是1的位置，结果才是1    |
| **并集** $S \cup T$          | `S \| T`                  | `int Union = S \| T;`              | `0111` (7)     | 两位中有一位是1的位置，结果就是1  |
| **对称差** $S \triangle T$   | `S ^ T`                   | `int SymDiff = S ^ T;`             | `0110` (6)     | 两位不同的位置，结果才是1         |
| **差集** $S \setminus T$     | `S & ~T`                  | `int Diff = S & ~T;`               | `0100` (4)     | 在S中但不在T中的元素              |
| **补集** $\complement_US$    | `Full ^ S` 或 `~S & Full` | `int Comp = Full ^ S;`             | `1010` (10)    | `Full` 是全集掩码 (如 `(1<<n)-1`) |
| **子集判断** $T \subseteq S$ | `(T & S) == T`            | `bool isSubset = (T & S) == T;`    | `true` (1==1)  | T 的所有 1 的位置，S 也必须是 1   |
| **父集判断** $S \supseteq T$ | `(S \| T) == S`           | `bool isSuperset = (S \| T) == S;` | `false` (7!=5) | S 必须包含 T 的所有元素           |

**注意**：直接使用 `~S` 求补集得到的是相对于当前数据类型全位集的补集（例如 32 位整数的全集是 `0xFFFFFFFF`）。在 OI 中，我们通常处理的是 **n 元素全集**，因此需要先定义一个全集掩码 `Full = (1 << n) - 1`，然后用 `Full ^ S` 来求补集，这才是安全的做法。

---

### 三、单点与状态操作

#### 1. 基础位操作 (假设操作第 `i` 位，从0开始计数)
| 操作             | 位运算表达式    | 代码示例                  |
| :--------------- | :-------------- | :------------------------ |
| **获取第i位**    | `(S >> i) & 1`  | `int bit = (S >> i) & 1;` |
| **设置第i位为1** | `S \| (1 << i)` | `S \|= (1 << i);`         |
| **设置第i位为0** | `S & ~(1 << i)` | `S &= ~(1 << i);`         |
| **翻转第i位**    | `S ^ (1 << i)`  | `S ^= (1 << i);`          |

#### 2. 常用宏/内联函数
为了代码简洁，常用如下定义：
```cpp
// 注意：如果i是变量，确保1是足够宽的类型（如1LL），或者使用强制转换
#define lowbit(x) ((x) & -(x))
#define getbit(s, i) (((s) >> (i)) & 1)
#define setbit1(s, i) ((s) | (1 << (i)))
#define setbit0(s, i) ((s) & ~(1 << (i)))
#define flipbit(s, i) ((s) ^ (1 << (i)))
```

---

### 四、高级技巧与应用

#### 1. `lowbit`：获取最低位的1
`x & -x` 可以获取 `x` 的二进制表示中最低位的 `1` 所对应的值。
**应用**：
- **树状数组 (Fenwick Tree)** 的核心。
- **遍历一个集合的所有元素**：
  ```cpp
  while (S) {
      int j = __builtin_ctz(S); // 或者自己算：j = __builtin_ctz(S);
      int element = lowbit(S); // 或者直接使用j
      // 处理元素 j
      S &= S - 1; // 或 S -= lowbit(S); 移除最低位的1
  }
  ```

#### 2. 枚举子集
- **枚举所有非空子集**：
  ```cpp
  for (int sub = S; sub; sub = (sub - 1) & S) {
      // sub 是 S 的一个非空子集
  }
  ```
- **枚举所有子集 (包含空集)**：
  ```cpp
  int sub = S;
  do {
      // 处理子集 sub
      sub = (sub - 1) & S;
  } while (sub != S); // 循环结束后会得到S，然后减一后变成(S-1)&S，下次循环条件不满足退出
  // 更直观的写法：
  for (int sub = S; ; sub = (sub - 1) & S) {
      // 处理子集 sub
      if (sub == 0) break;
  }
  ```

#### 3. 判断一个数是否为2的幂次
如果一个正整数 `x` 是 2 的幂次，那么它的二进制表示中有且仅有一个 `1`。
**方法**：`(x > 0) && ((x & (x - 1)) == 0)`
```cpp
bool isPowerOfTwo(int x) {
    return x > 0 && (x & (x - 1)) == 0;
}
```
**原理**：`x` 是2的幂次，形如 `00100000`；`x-1` 形如 `00011111`。两者相与，结果必然为0。

#### 4. 计算二进制中1的个数 (Popcount)
- **GCC/Clang 内置函数** (最快)：
  ```cpp
  __builtin_popcount(x);   // 32位 unsigned int
  __builtin_popcountll(x); // 64位 unsigned long long
  __builtin_popcountl(x);  // 根据 long 的大小
  ```
- **自己实现**：
  ```cpp
  int popcount(int x) {
      int cnt = 0;
      while (x) {
          cnt++;
          x &= x - 1; // 每次消除最低位的1
      }
      return cnt;
  }
  ```

#### 5. 其他实用技巧
- **判断奇偶性**：`x & 1`
- **乘以/除以2的n次幂**：`x << n` (乘), `x >> n` (除，需非负)
- **对2的n次幂取模**：`x & ((1 << n) - 1)`
- **交换两个数**：
  ```cpp
  a ^= b;
  b ^= a;
  a ^= b;
  ```
- **获取最高位的1** (需要 `__builtin_clz`)：
  ```cpp
  (1 << (31 - __builtin_clz(x))) // 对于32位整数
  ```

---

### 五、应用场景

1.  **状态压缩DP**：TSP、轮廓线DP、状压DP等。
2.  **树状数组**：核心 `lowbit` 操作。
3.  **子集枚举与生成**：暴力搜索、组合问题。
4.  **图论**：邻接矩阵、传递闭包、点集表示。
5.  **算法优化**：常数级优化、底层算法。
6.  **网络与编码**：掩码、标志位处理。

### 六、注意事项

1.  **优先级**：位运算优先级低于比较运算符和算术运算符。**务必多用括号**！
    `if (x & 1 == 0)` 等价于 `if (x & (1==0))`，这是错误的。应写为 `if ((x & 1) == 0)`。
2.  **位数与类型**：注意数据类型的位数 (`int`, `long long`)。移位操作中 `1 << 40` 对于 `int` 是未定义行为，应使用 `1LL << 40`。
3.  **符号位**：谨慎处理有符号数的右移 `>>` 和取反 `~` 操作，优先使用无符号类型 `unsigned int`。
